;;;;
;;;; Example for Domain Driven Design with a Hexagonal Architecture
;;;;
#{;;;
  ;;; Concept Model
  ;;;
  ;;
  ;; Concepts
  ;;
  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-abstract-core
   :tags #{"Pattern"}
   :name "Abstract Core"
   :desc "The most fundamental differentiating concepts in the model, factored
into distinct classes, abstract classes, or interfaces."
   :doc "Even the core domain model usually has so much detail that communicating the
big picture can be difficult.

When there is a lot of interaction between subdomains in separate modules,
either many references will have to be created between modules, which defeats
much of the value of the partitioning, or the interaction will have to be made
indirect, which makes the model obscure.

Therefore:

Identify the most fundamental differentiating concepts in the model and factor
them into distinct classes, abstract classes, or interfaces. Design this
abstract model so that it expresses most of the interaction between significant
components. Place this abstract overall model in its own module, while the
specialized, detailed implementation classes are left in their own modules
defined by subdomain."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-aggregates
   :tags #{"Pattern"}
   :name "Aggregates"
   :desc
   "Aggregates are collections of entities and value objects with their
associations and form a transactional unit. Aggregates are referenced as a
whole by an aggregate root entity, parts of the aggregate must not be
referenced from outside. The aggregate root is responsible for the enforcement
of the busines rules and invariants of the aggregate."
   :doc "It is difficult to guarantee the consistency of changes to objects in a model
with complex associations. Objects are supposed to maintain their own internal
consistent state, but they can be blindsighed by changes in other objects that
are conceptually constituent parts. Cautious database locking schemes cause
multiple users to interfere pointlessly with each other and can make a system
unusable. Similar issues arise when distributing objects among multiple
servers, or designing asynchronous transactions.

Therefore,

Cluster entities and value objects into aggregates and define boundaries around
each. Choose one entity to be the root of each aggregate, and allow external
objects to hold references to the root only (references to internal members
passed out for use within a single operation only). Define properties and
invariants for the aggregate as a whole and give enforcement responsibility to
the root or some designated framework mechanism.

Use the same aggregate boundaries to govern transactions and distribution.

Within the aggregate boundary, apply consistent rules synchronously. Across
boundaries, handle updates asynchronously.

Keep an aggregate together on one server. Allow diferent aggregate to be
distributed among nodes.

When these design decisions are not beeing guided well by the aggregate
boundaries, reconsider the model. Is the domain scenario hinting at an
important new insight? Such changes often improve the model's expressiveness
and flexibility as well as resolving the transactional and distribution issues."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-anti-corruption-layer
   :tags #{"Pattern"}
   :name "Anti-Corruption Layer"
   :desc
   "The anti-corruption layer is an architectural layer to separate the domain
model from outside models. It enables the domain model to access the data of
the outside model as expected by the domain model.
In a clean architecture, an adapter is the place to implement the anti-
corruption layer by mapping the outside model to the domain model."
   :doc "Translation layers can be simple, even elegant, when bridging well-designed
bounded contexts with cooperative teams. But when control or communication is
not adequate to pull off a shared kernel, partner or customer/supplier
relationship, translation becomes more complex. The translation layer takes on
a more defensive tone.

A large interface with an upstream system can eventually overwhelm the intent
of the downstream model altogether, causing it to be modified to resemble the
other system's model in an ad hoc fashion. The models of legacy systems are
usually weak (if not big balls of mud), and even the exception that is clearly
designed may not fit the needs of the current project, making it impractical to
conform to the upstream model. Yet the integration may be very valuable or even
required for the downstream project.

Therefore,

As a downstream client, create an isolating layer to provide your system with
functionality of the upstream system in terms of your own domain model.
This layer talks to the other system through its existing interface, requiring
little or no modification to the other system. Internally, the layer translates
in one or both directions as necessary between the two models."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-big-ball-of-mud
   :tags #{"Pattern"}
   :name "Big Ball of Mud"
   :desc "A Big Ball of Mud is a casually, even haphazardly, structured system.
Its organization, if one can call it that, is dictated more by expediency than
design. Yet, its enduring popularity cannot merely be indicative of a general
disregard for architecture."
   :doc "As we survey existing software systems, trying to understand how distinct
models are being applied within defined boundaries, we find parts of systems,
often large ones, where models are mixed and boundaries are inconsistent.

It is easy to get bogged down in an attempt to describe the context boundaries
of models in systems where there simply are no boundaries.

Well-defined context boundaries only emerge as a result of intellectual choices
and social forces (even though the people creating the systems may not always
have been consciously aware of these causes at the time). When these factors
are absent, or disappear, multiple conceptual systems and mix together, making
definitions and rules ambiguous or contradictory. The systems are made to work
by contingent logic as features are added. Dependencies crisscross the
software. Cause and effect become more and more difficult to trace. Eventually
the software congeals into a big ball of mud.

The big ball of mud is actually quite practical for some situations (as
described in the original article by Foote and Yoder), but it almost completely
prevents the subtlety and precision needed for useful models.

Therefore,

Draw a boundary around the entire mess and designate it a big ball of mud. Do
not try to apply sophisticated modeling within this context. Be alert to the
tendency for such systems to sprawl into other contexts.

(see [Big Ball of Mud - Brian Foote and Joseph Yoder](http://www.laputan.org/mud/mud.html))"}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-bounded-context
   :tags #{"Pattern"}
   :name "Bounded Context"
   :desc
   "A descrition of a boundary (typically a subsystem or the work of
a particular team) within which a particular model is defined and applicable."
   :doc "Multiple models are in play on any large project. They emerge for many reasons.
Two subsystems commonly serve very different user communities, with different
jobs, where different models may be useful. Teams working independently may
solve the same problem in different ways through lack of communication. The
tool set may also be different, meaning that program code cannot be shared.

Multiple models are inevitable, yet when code based on distinct models is
combined, software becomes buggy, unreliable, and difficult to understand.
Communication among team members becomes confused. It is often unclear in what
context a model should not be applied. Model expressions, like any other
phrase, only have meaning in context.

Therefore,

Explicitly define the context within which a model applies. Explicitly set
boundaries in terms of team organization, usage within specific parts of the
application, and physical manifestations such as code bases and database
schemas. Apply Continuous Integration to keep model concepts and terms
strictly consistent within these bounds, but don't be distracted or confused by
issues outside. Standardize a single development process within the context,
which need not be used elsewhere."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-cohesive-mechanisms
   :tags #{"Pattern"}
   :name "Cohesive Mechanisms"
   :desc ""
   :doc "Computations sometimes reach a level of complexity that begins to bloat the
design. The conceptual “what” is swamped by the mechanistic “how”. A large
number of methods that provide algorithms for resolving the problem obscure the
methods that express the problem.

Therefore:

Partition a conceptually cohesive mechanism into a separate lightweight
framework. Particularly watch for formalisms or well-documented categories of
algorithms. Expose the capabilities of the framework with an
intention-revealing interface. Now the other elements of the domain can focus
on expressing the problem (“what”), delegating the intricacies of the solution
(“how”) to the framework.

Factoring out generic subdomains reduces clutter, and cohesive mechanisms serve
to encapsulate complex operations. This leaves behind a more focused model,
with fewer distractions that add no particular value to the way users conduct
their activities. But you are unlikely ever to find good homes for everything
in the domain model that is not core. The segregated core takes a direct
approach to structurally marking off the core domain."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-conformist
   :tags #{"Pattern"}
   :name "Conformist"
   :desc ""
   :doc "When two development teams have an upstream/downstream relationship in which the
upstream has no motivation to provide for the downstream team’s needs, the
downstream team is helpless. Altruism may motivate upstream developers to make
promises, but they are unlikely to be fulfilled. Belief in those good
intentions leads the downstream team to make plans based on features that will
never be available. The downstream project will be delayed until the team
ultimately learns to live with what it is given. An interface tailored to the
needs of the downstream team is not in the cards.

Therefore,

Eliminate the complexity of translation between bounded contexts by slavishly
adhering to the model of the upstream team. Although this cramps the style of
the downstream designers and probably does not yield the ideal model for the
application, choosing conformity enormously simplifies integration. Also, you
will share a ubiquitous language with your upstream team. The upstream is in
the driver’s seat, so it is good to make communication easy for them. Altruism
may be sufficient to get them to share information with you."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-context
   :tags #{"Pattern"}
   :name "Context"
   :desc
   "The setting in which a word or statement appears that determines its meaning.
Statements about a model can only be understood in a context."
   :doc ""}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-context-map
   :tags #{"Pattern"}
   :name "Context Map"
   :desc
   " The context map provides an overview for all models and their boundaries and
interfaces."
   :doc "To plot strategy, we need a realistic, large-scale view of model development
extending across our project and others we integrate with.

An individual bounded context leaves some problems in the absence of a global
view. The context of other models may still be vague and in flux.

People on other teams won't be very aware of the context boundaries and will
unknowingly make changes that blur the edges or complicate the
interconnections. When connections must be made between different contexts,
they tend to bleed into each other.

Even when boundaries are clear, relationships with other contexts place
constraints on the nature of model or pace of change that is feasible. These
constraints manifest themselves primarily through non-technical channels that
are sometimes hard to relate to the design decisions they are affecting.

Therefore,

Identify each model in play on the project and define its bounded context.
This includes the implicit models of non-object-oriented subsystems.
Name each bounded context, and make the names part of the ubiquitous language.

Describe the points of contact between the models, outlining explicit
translation for any communication, highlighting any sharing, isolation
mechanisms, and levels of influence.

Map the existing terrain. Take up transformations later.

This map can be a basis for realistic design strategy.

The characterization of relationships is made more concrete in the following
pages, with a set of common patterns of relationships between bounded contexts."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-continuous-integration
   :tags #{"Pattern"}
   :name "Continuous Integration"
   :desc "A process of merging all code and other implementation artifacts
frequently, with automated tests to flag fragmentation quickly."
   :doc "Once a bounded context has been defined, we must keep it sound. When a number
of people are working in the same bounded context, there is a strong tendency
for the model to fragment.
The bigger the team, the bigger the problem, but as few as three or four people
can encounter serious problems. Yet breaking down the system into ever-smaller
contexts eventually loses a valuable level of integration and coherency.

Therefore,

Institute a process of merging all code and other implementation artifacts
frequently, with automated tests to flag fragmentation quickly.
Relentlessly exercise the ubiquitous language to hammer out a shared view of
the model as the concepts evolve in different people's heads."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-core-domain
   :tags #{"Pattern"}
   :name "Core Domain"
   :desc "The most valuable part of the domain model."
   :doc "In a large system, there are so many contributing components, all complicated
and all absolutely necessary to success, that the essence of the domain model,
the real business asset, can be obscured and neglected.

It is harsh reality that not all parts of the design are going to be equally
refined. Priorities must be set. To make the domain model an asset, the
critical core of that model has to be sleek and fully leveraged to create
application functionality. But scarce, highly skilled developers tend to
gravitate to technical infrastructure or neatly definable domain problems that
can be understood without specialized domain knowledge.

Therefore,

Boil the model down. Define a core domain and provide a means of easily
distinguishing it from the mass of supporting model and code. Bring the most
valuable and specialized concepts into sharp relief. Make the core small.

Apply top talent to the core domain, and recruit accordingly. Spend the effort
in the core to find a deep model and develop a supple design — sufficient to
fulfill the vision of the system.

Justify investment in any other part by how it supports the distilled core."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-customer-supplier
   :tags #{"Pattern"}
   :name "Customer/Supplier"
   :desc "A clear relationship between two teams, where the downstream team is the customer
of the upstream team."
   :doc "When two teams are in an upstream-downstream relationship, where the upstream
team may succeed independently of the fate of the downstream team, the needs of
the downstream come to be addressed in a variety of ways with a wide range of
consequences.

A downstream team can be helpless, at the mercy of upstream priorities.
Meanwhile, the upstream team may be inhibited, worried about breaking
downstream systems.
The problems of the downstream team are not improved by cumbersome change
request procedures with complex approval processes. And the freewheeling
development of the upstream team will stop if the downstream team has veto
power over changes.

Therefore,

Establish a clear customer/supplier relationship between the two teams, meaning
downstream priorities factor into upstream planning. Negotiate and budget tasks
for downstream requirements so that everyone understands the commitment and
schedule.

Agile teams can make the downstream team play the customer role to the upstream
team, in planning sessions. Jointly developed automated acceptance tests can
validate the expected interface from the upstream. Adding these tests to the
upstream team's test suite, to be run as part of its continuous integration,
will free the upstream team to make changes without fear of side effects
downstream."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-domain
   :tags #{"Pattern"}
   :name "Domain"
   :desc
   "A sphere of knowledge, influence or activity.
The subject area to which a user applies a program is the domain of the software."
   :doc ""}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-domain-events
   :tags #{"Pattern"}
   :name "Domain Events"
   :desc "A domain object to propagate relevant domain activities in a distributed system."
   :doc "Something happened that domain experts care about.

An entity is responsible for tracking its state and the rules regulating its
lifecycle. But if you need to know the actual causes of the state changes,
this is typically not explicit and it may be difficult to explain how the
system got the way it is. Audit trails can allow tracing, but are not usually
suited to being used for the logic of the program itself. Change histories of
entities can allow access to previous states, but ignores the meaning of those
changes, so that any manipulation of the information is procedural, and often
pushed out of the domain layer.

A distinct, though related set of issues arises in distributed systems. The
state of the distributed system cannot be kept completely consistent at all
times. We keep the Aggregates internally consistent at all times, while making
other changes asynchronously. As changes propagate across nodes of a network,
it can be difficult to resolve multiple updates arriving out of order or from
distinct sources.

Therefore,

Model information about activity in the domain as a series of discrete events.
Represent each event as a domain object. These are distinct from system events
that reflect activity within the software itself, although often a system
event is associated with a domain event, either as part of a response to the
domain event or as a way of carrying information about the domain event into
the system.

A domain event is a full-fledged part of the domain model, a representation of
something that happened in the domain. Ignore irrelevant domain activity while
making explicit the events that the domain experts want to track or be notified
of, or which are associated whith the state change in other model objects.

In a distributed system, the state change of an entity can be inferred from the
domain events currently known to a particular node, allowing a cohrent model in
the absence of full information about the system as a whole.

Domain events are ordinarily immutable, as they are a record of something in
the past. In addition to the description of the event, a domain event typically
contains a timestamp for the time the event occured and the identity of
entities involved in the event. Also a domain event often has a separate
timestamp indicating when the event was entered into the system and the
identity of the person who entered it. When usefull, an identity for the domain
event can be based on some set of these properties. So, for example, if two
instances of the same event arrive at a node they can be recognised to be the
same."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-domain-vision-statement
   :tags #{"Pattern"}
   :name "Domain Vision Statement"
   :desc "A short description of the core domain and the value it will bring."
   :doc "At the beginning of a project, the model usually doesn't even exist, yet the
need to focus its development is already there. In later stages of development,
there is a need for an explanation of the value of the system that does not
require an in-depth study of the model. Also, the critical aspects of the
domain model may span multiple bounded contexts, but by definition these
distinct models can't be structured to show their common focus.

Therefore:

Write a short description (about one page) of the core domain and the value it
will bring, the “value proposition”. Ignore those aspects that do not
distinguish this domain model from others. Show how the domain model serves and
balances diverse interests. Keep it narrow. Write this statement early and
revise it as you gain new insight."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-entities
   :tags #{"Pattern"}
   :name "Entities"
   :desc
   "Objects in the domain model which are defined by their identity rather than
by their state. For example a Person is normally modelled as an entity. It
represents the same person even when the attributes change. It is also a
different person, even if it has the same state as another person."
   :doc "Many objects represent a thread of continuity and identity, going through a
lifecycle, though their attributes may change.

Some objects are not defined primarily by their attributes. They represent a
thread of identity that runs though time and often across distinct
representations. Sometimes such an object must be matched with another object
even though attributes differ. An object must be distinguished from other
objects even though they might have the same attributes. Mistaken identity
can lead to data corruption.

Therefore,

When an object is distinguished by its identity, rathe than its attributes,
make this primary to its definition in the model. Keep the class definition
simple and focused on lifecycle continuity and identity.

Define a means of distinguishing each object regardless of its form or history.
Be alert to requirements that call for matching objects by attributes. Define
an operation that is guaranteed to produce a unique result for each object,
possibly by attaching a symbol that is guaranteed unique. This means of
identification may come from the outside, or it may be an arbitrary identifier
created by and for the system, but it must correspond to the identity
distinctions in the model.

The model must define what it means to be the same thing."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-evolving-order
   :tags #{"Pattern"}
   :name "Evolving Order"
   :desc "A conceptual large-scale structure that evolves with the application, possibly
changing to a completely different type of structure along the way."
   :doc "Design free-for-alls produce systems no one can make sense of as a whole, and
they are very difficult to maintain. But architectures can straitjacket a
project with up-front design assumptions and take too much power away from the
developers/designers of particular parts of the application. Soon, developers
will dumb down the application to fit the structure, or they will subvert it
and have no structure at all, bringing back the problems of uncoordinated
development.

Therefore:

Let this conceptual large-scale structure evolve with the application, possibly
changing to a completely different type of structure along the way. Don't over
constrain the detailed design and model decisions that must be made with
detailed knowledge.

Large-scale structure should be applied when a structure can be found that
greatly clarifies the system without forcing unnatural constraints on model
development. Because an ill-fitting structure is worse than none, it is best
not to shoot for comprehensiveness, but rather to find a minimal set that
solves the problems that have emerged. Less is more.

What follows is a set of four particular patterns of large-scale structure that
emerge on some projects and are representative of this kind of pattern."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-factories
   :tags #{"Pattern"}
   :name "Factories"
   :desc "A domain object for the creation of complex domain objects which enforce the
invariants of these objects on creation."
   :doc "When creation of an object, or an entire AGGREGATE, becomes complicated or
reveals too much of the internal structure, FACTORIES provide encapsulation.

Creation of an object can be a major operation in itself, but complex assembly
operations do not fit the responsibility of the created objects. Combining such
responsibilities can produce ungainly designs that are hard to understand.
Making the client direct construction  muddies the design of the client,
breaches encapsulation of the assembled object or AGGREGATE, and overly couples
the client to the implementation of the created object.

Therefore,

Shift the responsibility for creating instances of complex objects and
AGGREGATES to a separate object, which may itself have no responsibility in the
domain model but is still part of the domain design. Provide an interface that
encapsulates all complex assembly and that does not require the client to
reference the concrete classes of the objects being instantiated. Create entire
AGGREGATES as a piece, enforcing their invariants."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-generic-subdomains
   :tags #{"Pattern"}
   :name "Generic Subdomains"
   :desc "A cohesive subdomain that is not the motivation for the project and does
not capoure specialized knowledge."
   :doc "Some parts of the model add complexity without capturing or communicating
specialized knowledge. Anything extraneous makes the core domain harder to
discern and understand. The model clogs up with general principles everyone
knows or details that belong to specialties which are not your primary focus
but play a supporting role. Yet, however generic, these other elements are
essential to the functioning of the system and the full expression of the
model.

Therefore,

Identify cohesive subdomains that are not the motivation for your project.
Factor out generic models of these subdomains and place them in separate
modules. Leave no trace of your specialties in them.

Once they have been separated, give their continuing development lower priority
than the core domain, and avoid assigning your core developers to the tasks
(because they will gain little domain knowledge from them). Also consider
off-the-shelf solutions or published models for these generic subdomains."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-hands-on-modellers
   :tags #{"Pattern"}
   :name "Hands On Modellers"
   :desc "Developers must be involved with the model and have contact with domain experts."
   :doc "If the people who write the code do not feel responsible for the model, or
don't understand how to make the model work for an application, then the model
has nothing to do with the software. If developers don't realize that changing
code changes the model, then their refactoring will weaken the model rather
than strengthen it. Meanwhile, when a modeler is separated from the
implementation process, he or she never acquires, or quickly loses, a feel for
the constraints of implementation.
The basic constraint of MODEL-DRIVEN DESIGN —that the model supports an
effective implementation and abstracts key insights into the domain—
is half-gone, and the resulting models will be impractical. Finally, the
knowledge and skills of experienced designers won't be transferred to other
developers if the division of labor prevents the kind of collaboration that
conveys the subtleties of coding a MODEL-DRIVEN DESIGN.


Therefore,

Any technical person contributing to the model must spend some time touching
the code, whatever primary role he or she plays on the project. Anyone
responsible for changing code must learn to express a model through the code.
Every developer must be involved in some level of discussion about the model
and have contact with domain experts. Those who contribute in different ways
must consciously engage those who touch the code in a dynamic exchange of model
ideas through the UBIQUITOUS LANGUAGE."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-highlighted-core
   :tags #{"Pattern"}
   :name "Highlighted Core"
   :desc "Describes the core elements of the domain and their interactions."
   :doc "A domain vision statement identifies the core domain in broad terms, but it
leaves the identification of the specific core model elements up to the
vagaries of individual interpretation. Unless there is an exceptionally high
level of communication on the team, the vision statement alone will have
little impact.

Even though team members may know broadly what constitutes the core domain,
different people won't pick out quite the same elements, and even the same
person won't be consistent from one day to the next. The mental labor of
constantly filtering the model to identify the keyparts absorbs concentration
better spent on design thinking, and it requires comprehensive knowledge of the
model. The core domain must be made easier to see.

Significant structural changes to the code are the ideal way of identifying the
core domain, but they are not always practical in the short term. In fact, such
major code changes are difficult to undertake without the very view the team is
lacking.

Therefore (as one form of highlighted core):

Write a very brief document (three to seven sparse pages) that describes the
core domain and the primary interactions among core elements.

and/or (as another form of highlighted core):

Flag the elements of the core domain within the primary repository of the
model, without particularly trying to elucidate its role. Make it effortless
for a developer to know what is in or out of the core.

If the distillation document outlines the essentials of the core domain, then
it serves as a practical indicator of the significance of a model change. When
a model or code change affects the distillation document, it requires
consultation with other team members. When the change is made, it requires
immediate notification of all team members, and the dissemination of a new
version of the document. Changes outside the core or to details not included in
the distillation document can be integrated without consultation or
notification and will be encountered by other members in the course of their
work. Then the developers have the full autonomy that most Agile processes
suggest.

Although the vision statement and highlighted core inform and guide, they do
not actually modify the model or the code itself. Partitioning generic
subdomains physically removes some distracting elements. Next we'll look at
other ways to structurally change the model and the design itself to make the
core domain more visible and manageable."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-knowledge-level
   :tags #{"Pattern"}
   :name "Knowledge-level"
   :desc "A distinct set of objects that can be used to describe and constrain the
structure and behavior of the basic model."
   :doc "A group of objects that describe how another group of objects should behave.

In an application in which the roles and relationships between entities vary in
different situations, complexity can explode. Neither fully general models nor
highly customized ones serve the users' needs. Objects end up with references
to other types to cover a variety of cases, or with attributes that are used in
different ways in different situations. Classes that have the same data and
behavior may multiply just to accommodate different assembly rules.

Therefore:

Create a distinct set of objects that can be used to describe and constrain the
structure and behavior of the basic model. Keep these concerns separate as two
“levels,” one very concrete, the other reflecting rules and knowledge that a
user or super-user is able to customize.

(see Fowler, M. 1997. Analysis Patterns: Reusable Object Models, Addison-Wesley.)"}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-clean-architecture
   :tags #{"Pattern"}
   :name "Clean Architecture"
   :desc ""
   :doc ""}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-large-scale-structure
   :tags #{"Pattern"}
   :name "Large Scale Structure"
   :desc ""
   :doc "Even the core domain model usually has so much detail that communicating the
big picture can be difficult.

When there is a lot of interaction between subdomains in separate modules,
either many references will have to be created between modules, which defeats
much of the value of the partitioning, or the interaction will have to be made
indirect, which makes the model obscure.

Therefore:

Identify the most fundamental differentiating concepts in the model and factor
them into distinct classes, abstract classes, or interfaces. Design this
abstract model so that it expresses most of the interaction between significant
components. Place this abstract overall model in its own module, while the
specialized, detailed implementation classes are left in their own modules
defined by subdomain."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-layered-archtecture
   :tags #{"Pattern"}
   :name "Layered Architecture"
   :desc "Isolates the expression of the domain model and the business logic, and
eliminates any dependency on infrastructure, user interface, or application logic
that is not business logic."
   :doc "In an object-oriented program, UI, database, and other support code often gets
written directly into the business objects. Additional business logic is
embedded in the behavior of UI widgets and database scripts. This happens
because it is the easiest way to make things work, in the short run.

When the domain-related code is diffused through such a large amount of other
code, it becomes extremely difficult to see and to reason about. Superficial
changes to the UI can actually change business logic. To change a business rule
may require meticulous tracing of UI code, database code, or other program
elements. Implementing coherent, model-driven objects becomes impractical.
Automated testing is awkward. With all the technologies and logic involved in
each activity, a program must be kept very simple or it becomes impossible to
understand.

Therefore,

Isolate the expression of the domain model and the business logic, and
eliminate any dependency on infrastructure, user interface, or even
application logic that is not business logic. Partition a complex program
into layers. Develop a design within each layer that is cohesive and that
depends only on the layers below. Follow standard architectural patterns to
provide loose coupling to the layers above. Concentrate all the code related
to the domain model in one layer and isolate it from the user interface,
application, and infrastructure code. The domain objects, free of the
responsibility of displaying themselves, storing themselves, managing
application tasks, and so forth, can be focused on expressing the domain model.
This allows a model to evolve to be rich enough and clear enough to capture
essential business knowledge and put it to work.

The key goal here is isolation. Related patterns, such as “Hexagonal
Architecture” may serve as well or better to the degree that they allow our
domain model expressions to avoid dependencies on and references to other
system concerns."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-model
   :tags #{"Pattern"}
   :name "Model"
   :desc
   "A system of abstractions that describes selected aspects of a domain
and can be used to solve problems related to that domain."
   :doc ""}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :tags #{"Pattern"}
   :name "Model Driven Design"
   :desc ""
   :doc "Tightly relating the code to an underlying model gives the code meaning and
makes the model relevant.

If the design, or some central part of it, does not map to the domain model,
that model is of little value, and the correctness of the software is suspect.
At the same time, complex mappings between models and design functions are
difficult to understand and, in practice, impossible to maintain as the design
changes. A deadly divide opens between analysis and design so that insight
gained in each of those activities does not feed into the other.


Therefore,

Design a portion of the software system to reflect the domain model in a very
literal way, so that mapping is obvious. Revisit the model and modify it to be
implemented more naturally in software, even as you seek to make it reflect
deeper insight into the domain. Demand a single model that serves both purposes
well, in addition to supporting a fluent UBIQUITOUS LANGUAGE. 
Draw from the model the terminology used in the design and the basic assignment
of responsibilities. The code becomes an expression of the model, so a change
to the code may be a change to the model. Its effect must ripple through the
rest of the project's activities accordingly.
To tie the implementation slavishly to a model usually requires software
development tools and languages that support a modeling paradigm, such as
object-oriented programming."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-modules
   :tags #{"Pattern"}
   :name "Modules"
   :desc ""
   :doc "Everyone uses modules, but few treat them as a full-fledged part of the model.
Code gets broken down into all sorts of categories, from aspects of the
technical architecture to developers' work assignments. Even developers who
refactor a lot tend to content themselves with modules conceived early in the
project.

Explanations of coupling and cohesion tend to make them sound like technical
metrics, to be judged mechanically based on the distributions of associations
and interactions. Yet it isn't just code being divided into modules, but
concepts. There is a limit to how many things a person can think about at once
(hence low coupling). Incoherent fragments of ideas are as hard to understand
as an undifferentiated soup of ideas (hence high cohesion).

Therefore,

Choose modules that tell the story of the system and contain a cohesive set of
concepts. Give the modules names that become part of the ubiquitous language.
Modules and their names should reflect insight into the domain.

This often yields low coupling between modules, but if it doesn't look for a
way to change the model to disentangle the concepts, or an overlooked concept
that might be the basis of a module that would bring the elements together in a
meaningful way. Seek low coupling in the sense of concepts that can be
understood and reasoned about independently. Refine the model until it
partitions according to high-level domain concepts and the corresponding code
is decoupled as well."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-open-host-service
   :tags #{"Pattern"}
   :name "Open Host Service"
   :desc "An open protocol that gives access to your subsystem as a set of services."
   :doc "Typically for each bounded context, you will define a translation layer for
each component with which you have to integrate that is outside the context.
Where integration is one-off, this approach of inserting a translation layer
for each external system avoids corruption of the models with a minimum of
cost. But when you find your subsystem in high demand, you may need a more
flexible approach.

When a subsystem has to be integrated with many others, customizing a
translator for each can bog down the team. There is more and more to maintain,
and more and more to worry about when changes are made.

Therefore,

Define a protocol that gives access to your subsystem as a set of services.
Open the protocol so that all who need to integrate with you can use it.
Enhance and expand the protocol to handle new integration requirements, except
when a single team has idiosyncratic needs. Then, use a one-off translator to
augment the protocol for that special case so that the shared protocol can stay
simple and coherent.

This places the provider of the service in the upstream position. Each client
is downstream, and typically some of them will be conformist and some will
build anticorruption layers. A context with an open host service might have any
sort of relationship to contexts other than its clients."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-partnership
   :tags #{"Pattern"}
   :name "Partnership"
   :desc "A partnership between the teams in charge of the two
contexts, when the teams will succeed or fail together."
   :doc "When teams in two contexts will succeed or fail together, a cooperative
relationship often emerges.

Poor coordination of mutually dependent subsystems in separate contexts leads
to delivery failure for both projects. A key feature missing from one system
might make the other system undeliverable. Interfaces that do not match the
expectations of the developers of the other subsystem could cause integration
to fail. A mutually agreed interface might turn out to be so awkward to use
that it slows the development of the client system, or so difficult to
implement that it slows the development of the server subsystem. Failure
brings both projects down.

Therefore,

Where development failure in either of two contexts would result in delivery
failure for both, forge a partnership between the teams in charge of the two
contexts. Institute a process for coordinated planning of development and
joint management of integration.

The teams must cooperate on the evolution of their interfaces to accommodate
the development needs of both systems. Interdependent features should be
scheduled so that they are completed for the same release.

It is not necessary, most of the time, for developers to understand the model
of the other subsystem in detail, but they must coordinate their project
planning. When development in one context hits obstacles, then joint
examination of the issue is called for, to find an expeditious design solution
that does not overly compromise either context.

Also, a clear process is needed to govern integration. For example, a special
test suite can be defined that proves the interface meets the expectations of
the client system, which can be run as part of continuous integration on the
server system."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-pluggable-component-framework
   :tags #{"Pattern"}
   :name "Pluggable Component Framework"
   :desc "A framework that allows diverse implementations of those interfaces to be
freely substituted."
   :doc "Opportunities arise in a very mature model that is deep and distilled. A
pluggable component framework usually only comes into play after a few
applications have already been implemented in the same domain.

When a variety of applications have to interoperate, all based on the same
abstractions but designed independently, translations between multiple bounded
contexts limit integration. A shared kernel is not feasible for teams that do
not work closely together. Duplication and fragmentation raise costs of
development and installation, and interoperability becomes very difficult.

Therefore:

Distill an abstract core of interfaces and interactions and create a framework
that allows diverse implementations of those interfaces to be freely
substituted. Likewise, allow any application to use those components, so long
as it operates strictly through the interfaces of the abstract core."}
  
  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-published-language
   :tags #{"Pattern"}
   :name "Published Language"
   :desc "A well-documented shared language that can express the necessary domain
information as a common medium of communication, translating as necessary into
and out of that language."
   :doc "The translation between the models of two bounded contexts requires a common
language.

Direct translation to and from the existing domain models may not be a good
solution. Those models may be overly complex or poorly factored. They are
probably undocumented. If one is used as a data interchange language, it
essentially becomes frozen and cannot respond to new development needs.

Therefore,

Use a well-documented shared language that can express the necessary domain
information as a common medium of communication, translating as necessary into
and out of that language.

Many industries establish published languages in the form of data interchange
standards. Project teams also develop their own for use within their
organization.

Published language is often combined with open-host service."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-repositories
   :tags #{"Pattern"}
   :name "Repositories"
   :desc ""
   :doc "Query access to aggregates expressed in the ubiquitous language.

Proliferation of traversable associations used only for finding things muddles
the model. In mature models, queries often express domain concepts. Yet queries
can cause problems.

The sheer technical complexity of applying most database access infrastructure
quickly swamps the client code, which leads developers to dumb-down the domain
layer, which makes the model irrelevant. 

Aquery framework may encapsulate most of that technical complexity, enabling
developers to pull the exact data they need from the database, but that only
solves part of the problem.

Unconstraint queries may pull specific fields from objects, breaching
encapsulation, or instantiate a few specific objects from the interior of an
aggregate, blindsighting the aggregate root and making it impossible for these
objects to enforce the rules of the domain model. Domain logic moves into
queries and application layer code, and the entities and value objects become
mere data containers.

Therefore,

For each type of aggregate that needs global access, create a service that can
provide the illusion of an in-memory collection of all objects of that
aggregate's root type. Set up access through a well-known global interface.
Provide methods to add and remove object, which will encapsulate the actual
insertion or removal of data in the data store. Provide methods that select
objects based on criteria meaningful to domain experts. Return fully
instanciated objects or collection of objects whose attribute values meet the
criteria, thereby encapsulating the actual storage and query technology, or
return proxies that give the illusion of fully instantiated aggregates in a
lazy way. Provide repositories only for aggregate roots that actually need
direct access. Keep application logic focussed on the model, delegating all
object storage and access to the repository."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-responsibility-layers
   :tags #{"Pattern"}
   :name "Responsibility Layers"
   :desc ""
   :doc "In object-oriented design, individual objects are assigned narrow sets of
related responsibilities. Responsibility-driven design also applies to larger
scales.

When each individual object has handcrafted responsibilities, there are no
guidelines, no  uniformity, and no ability to handle large swaths of the
domain together. To give coherence to a large model, it is useful to impose
some structure on the assignment of those responsibilities.

Therefore:

Look at the conceptual dependencies in your model and the varying rates and
sources of change of different parts of your domain. If you identify natural
strata in the domain, cast them as broad abstract responsibilities. These
responsibilities should tell a story of the high-level purpose and design of
your system. Refactor the model so that the responsibilities of each domain
object, aggregate, and module fit neatly within the responsibility of one
layer."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-segregated-core
   :tags #{"Pattern"}
   :name "Segregated Core"
   :desc ""
   :doc "Elements in the model may partially serve the core domain and partially play
supporting roles. Core elements may be tightly coupled to generic ones. The
conceptual cohesion of the core may not be strong or visible. All this clutter
and entanglement chokes the core. Designers can't clearly see the most
important relationships, leading to a weak design.

Therefore:

Refactor the model to separate the core concepts from supporting players
(including ill-defined ones) and strengthen the cohesion of the core while
reducing its coupling to other code. Factor all generic or supporting
elements into other objects and place them into other packages, even if this
means refactoring the model in ways that separate highly coupled elements."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-separate-ways
   :tags #{"Pattern"}
   :name "Separate Ways"
   :desc "A bounded context with no connection to the others at all, allowing
developers to find simple, specialized solutions within this small scope."
   :doc "We must be ruthless when it comes to defining requirements. If two sets of
functionality have no significant relationship, they can be completely cut
loose from each other.

Integration is always expensive, and sometimes the benefit is small.

Therefore,

Declare a bounded context to have no connection to the others at all, allowing
developers to find simple, specialized solutions within this small scope."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-services
   :tags #{"Pattern"}
   :name "Services"
   :desc ""
   :doc "Sometimes, it just isn't a thing.

Some concepts from the domain aren't natural to model as objects. Forcing the
required domain functionality to be the responsibility of an ENTITY or VALUE
either distorts the definition of a model-based object or adds meaningless
artificial objects.

Therefore,

When a significant process or transformation in the domain is not a natural
responsibility of an ENTITY or VALUE OBJECT, add an operation to the model
as a standalone interface declared as a SERVICE. Define a service contract, a
set of assertions about interactions with the service. (See assertions.) State
these assertions in the ubiquitous language of a specific bounded context.
Give the service a name, which also becomes part of the ubiquitous language."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-shared-kernel
   :tags #{"Pattern"}
   :name "Shared Kernel"
   :desc ""
   :doc "Sharing a part of the model and associated code is a very intimate
interdependency, which can leverage design work or undermine it.

When functional integration is limited, the overhead of continuous integration
of a large context may be deemed too high. This may especially be true when
the team does not have the skill or the political organization to maintain
continuous integration, or when a single team is simply too big and unwieldy.
So separate bounded contexts might be defined and multiple teams formed.

Once separate, uncoordinated teams working on closely related applications can
go racing forward for a while, but what they produce may not fit together. Even
partner teams can end up spending a great deal on translation layers and
retrofitting, meanwhile duplicating effort and losing the benefits of a common
ubiquitous language.

Therefore,

Designate with an explicit boundary some subset of the domain model that the
teams agree to share. Keep this kernel small.

Within this boundary, include, along with this subset of the model, the subset
of code or of the database design associated with that part of the model. This
explicitly shared stuff has special status, and shouldn't be changed without
consultation with the other team.

Define a continuous integration process that will keep the kernel model tight
and align the ubiquitous language of the teams. Integrate a functional system
frequently, though somewhat less often than the pace of continuous integration
within the teams."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-system-metaphor
   :tags #{"Pattern"}
   :name "System Metaphor"
   :desc ""
   :doc "Metaphorical thinking is pervasive in software development, especially with
models. But the Extreme Programming practice of “metaphor” has come to mean a
particular way of using a metaphor to bring order to the development of a
whole system.

Software designs tend to be very abstract and hard to grasp. Developers and
users alike need tangible ways to understand the system and share a view of the
system as a whole.

Therefore:

When a concrete analogy to the system emerges that captures the imagination of
team members and seems to lead thinking in a useful direction, adopt it as a
large-scale structure. Organize the design around this metaphor and absorb it
into the ubiquitous language. The system metaphor should both facilitate
communication about the system and guide development of it. This increases
consistency in different parts of the system, potentially even across different
bounded contexts. But because all metaphors are inexact, continually reexamine
the metaphor for overextension or inaptness, and be ready to drop it if it gets
in the way."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-ubiquitous-language
   :tags #{"Pattern"}
   :name "Ubiquitous Language"
   :desc
   "A language around the domain model used by all team members within a
bounded context to connect all the activities of the team with the software."
   :doc "To create a supple, knowledge-rich design calls for a versatile, shared team
language, and a lively experimentation with language that seldom happens on
software projects.

A project faces serious problems when its language is fractured. Domain experts
use their jargon while technical team members have their own language tuned for
discussing the domain in terms of design. The terminology of day-to-day
discussions is disconnected from the terminology embedded in the code
(ultimately the most important product of a software project). And even the
same person uses different language in speech and in writing, so that the most
incisive expressions of the domain often emerge in a transient form that is
never captured in the code or even in writing.

Translation blunts communication and makes knowledge crunching anemic. Yet none
of these dialects can be a common language because none serves all needs.

Domain experts should object to terms or structures that are awkward or
inadequate to convey domain understanding; developers should watch for
ambiguity or inconsistency that will trip up design.

Play with the model as you talk about the system. Describe scenarios out loud
using the elements and interactions of the model, combining concepts in ways
allowed by the model. Find easier ways to say what you need to say, and then
take those new ideas back down to the diagrams and code.

With a ubiquitous language, the model is not just a design artifact. It becomes
integral to everything the developers and domain experts do together.

Therefore,

Use the model as the backbone of a language. Commit the team to exercising that
language relentlessly in all communication within the team and in the code.
Use the same language in diagrams, writing, and especially speech.

Iron out difficulties by experimenting with alternative expressions, which
reflect alternative models. Then refactor the code, renaming classes, methods,
and modules to conform to the new model. Resolve confusion over terms in
conversation, in just the way we come to agree on the meaning of ordinary
words.

Recognize that a change in the language is a change to the model."}

  {:el :concept
   :id :softwaredevelopment.domaindrivendesign/c-value-objects
   :tags #{"Pattern"}
   :name "Value Objects"
   :desc
   "An object in the domain model, which has no conceptional identity but are
identified by their state. Value objects should be modelled as immutable."
   :doc "Some objects describe or compute some characteristics of a thing.

Many objects have no conceptual identity.

Tracking the identity of entities is essential, but attaching identity to other
objects can hurt system performance, add analytical work, and muddle the model
by making all objects look the same. Software design is a constant battle with
complexity. We must make distinctions so that special handling is applied only
where neccessary.

However, if we think of this category of objects as just the absence of
identity, we havent added much to our toolbox or vocabulary. In fact, these
objects have characteristics of their own, and their own significance in the
model. These are objects that describe things.


Therefore,

When you care only about the attributes of an element of the model, classify it
as a value object. Make it express the meaning of the attributes it conveys and
give it related functionality.
Treat the value object as immutable. Make all operations Side-effect-free
Functions that don't depend on any mutable state. Don't give a value object any
identity and avoid the design complexities neccessary to maintain entities."}

  ;;
  ;; Relations
  ;;
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-core-domain-to-c-ubiquitous-language
   :from :softwaredevelopment.domaindrivendesign/c-core-domain
   :to :softwaredevelopment.domaindrivendesign/c-ubiquitous-language
   :name "culivate rich model with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-core-domain-to-c-generic-subdomains
   :from :softwaredevelopment.domaindrivendesign/c-core-domain
   :to :softwaredevelopment.domaindrivendesign/c-generic-subdomains
   :name "avoid overinvesting in"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-core-domain-work-in-c-bounded-context
   :from :softwaredevelopment.domaindrivendesign/c-core-domain
   :to :softwaredevelopment.domaindrivendesign/c-bounded-context
   :name "work in autonomous, clean"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-bounded-context-names-enter-c-ubiquitous-language
   :from :softwaredevelopment.domaindrivendesign/c-bounded-context
   :to :softwaredevelopment.domaindrivendesign/c-ubiquitous-language
   :name "names enter"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-bounded-context-overview-with-c-context-map
   :from :softwaredevelopment.domaindrivendesign/c-bounded-context
   :to :softwaredevelopment.domaindrivendesign/c-context-map
   :name "assess/overview relationships with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-bounded-context-with-c-continuous-integration
   :from :softwaredevelopment.domaindrivendesign/c-bounded-context
   :to :softwaredevelopment.domaindrivendesign/c-continuous-integration
   :name "keep model unified with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-structures-c-ubiquitous-language
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-ubiquitous-language
   :name "model gives structure to"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-within-c-bounded-context
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-bounded-context
   :name "define model within"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-express-with-c-services
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-services
   :name "express model with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-express-with-c-domain-events
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-domain-events
   :name "express change with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-express-with-c-entities
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-entities
   :name "express identity with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-express-with-c-value-objects
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-value-objects
   :name "express state and computation with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-model-driven-design-isolate-with-c-hexagonal-architecture
   :from :softwaredevelopment.domaindrivendesign/c-model-driven-design
   :to :softwaredevelopment.domaindrivendesign/c-clean-architecture
   :name "isolate domain expressions with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-entities-push-change-with-c-domain-events
   :from :softwaredevelopment.domaindrivendesign/c-entities
   :to :softwaredevelopment.domaindrivendesign/c-domain-events
   :name "push state change with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-entities-access-with-c-repositories
   :from :softwaredevelopment.domaindrivendesign/c-entities
   :to :softwaredevelopment.domaindrivendesign/c-repositories
   :name "access with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-entities-encapsulate-with-c-aggregates
   :from :softwaredevelopment.domaindrivendesign/c-entities
   :to :softwaredevelopment.domaindrivendesign/c-aggregates
   :name "encapsulate with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-entities-root-of-c-aggregates
   :from :softwaredevelopment.domaindrivendesign/c-entities
   :to :softwaredevelopment.domaindrivendesign/c-aggregates
   :name "act as root of"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-entities-encapsulate-with-c-factories
   :from :softwaredevelopment.domaindrivendesign/c-entities
   :to :softwaredevelopment.domaindrivendesign/c-factories
   :name "encapsulate with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-value-objects-encapsulate-with-c-aggregates
   :from :softwaredevelopment.domaindrivendesign/c-value-objects
   :to :softwaredevelopment.domaindrivendesign/c-aggregates
   :name "encapsulate with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-value-objects-encapsulate-with-c-factories
   :from :softwaredevelopment.domaindrivendesign/c-value-objects
   :to :softwaredevelopment.domaindrivendesign/c-factories
   :name "encapsulate with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-aggregates-encapsulate-with-c-factories
   :from :softwaredevelopment.domaindrivendesign/c-aggregates
   :to :softwaredevelopment.domaindrivendesign/c-factories
   :name "encapsulate with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-aggregates-access-with-c-repositories
   :from :softwaredevelopment.domaindrivendesign/c-aggregates
   :to :softwaredevelopment.domaindrivendesign/c-repositories
   :name "access with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-coordinate-with-c-partnership
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-partnership
   :name "coordinate interdependent contexts"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-overlap-contexts-c-shared-kernel
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-shared-kernel
   :name "overlap contexts"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-coordinate-c-customer-supplier
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-customer-supplier
   :name "coordinate upstream/downstream"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-overlap-c-conformist
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-conformist
   :name "overlap unilaterally as"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-translate-c-anti-corruption-layer
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-anti-corruption-layer
   :name "translate and isolate unilaterally with"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-support-c-open-host-service
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-open-host-service
   :name "support multiple clients through"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-go-c-separate-ways
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-separate-ways
   :name "free teams to go"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-context-map-seggregate-c-big-ball-of-mud
   :from :softwaredevelopment.domaindrivendesign/c-context-map
   :to :softwaredevelopment.domaindrivendesign/c-big-ball-of-mud
   :name "seggregate the conceptual messes"
   :desc ""}
  {:el :rel
   :id :softwaredevelopment.domaindrivendesign/c-open-host-service-formalized-as-c-published-language
   :from :softwaredevelopment.domaindrivendesign/c-open-host-service
   :to :softwaredevelopment.domaindrivendesign/c-published-language
   :name "formalized as"
   :desc ""}}